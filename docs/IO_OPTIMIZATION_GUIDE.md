# I/O 性能优化指南

## 问题诊断

根据系统监控，发现：
- **磁盘I/O瓶颈**：sdb设备利用率99.6%，读取速度237 MB/s，写入17 MB/s
- **系统负载高**：Load Average 136，但CPU使用率相对较低（8.9%），说明大量时间在等待I/O
- **I/O等待时间**：wa (I/O wait) 高达41-70%

## 优化策略

### 1. 数据加载优化

#### 1.1 NPZ文件读取优化
- ✅ **已实现**：使用`mmap_mode="r"`减少内存拷贝
- 🔧 **可改进**：
  - 预加载NPZ文件索引到内存
  - 使用`np.load()`的`allow_pickle=False`（如果不需要pickle对象）
  - 批量读取多个特征到内存缓存

#### 1.2 图像加载优化
- ❌ **当前问题**：每次`__getitem__`都从磁盘读取图像
- 🔧 **解决方案**：
  - 使用图像缓存（LRU Cache）
  - 预加载常用图像到内存
  - 使用更快的图像库（如`turbojpeg`）

#### 1.3 DataLoader优化
- ✅ **已实现**：`pin_memory=True`, `persistent_workers=True`
- 🔧 **可改进**：
  - 增加`prefetch_factor`（默认2，可设为4-8）
  - 增加`num_workers`（根据CPU核心数调整）
  - 使用`prefetch_generator`库异步预取

### 2. Checkpoint保存优化

#### 2.1 异步保存
- ❌ **当前问题**：同步保存阻塞训练
- 🔧 **解决方案**：
  - 使用后台线程异步保存checkpoint
  - 使用`torch.save()`的`_use_new_zipfile_serialization=False`（如果兼容）
  - 保存到临时文件后原子替换

#### 2.2 减少保存频率
- 只在关键epoch保存完整checkpoint
- 使用轻量级checkpoint（仅保存必要参数）

### 3. 特征缓存优化

#### 3.1 内存缓存
- 使用`functools.lru_cache`缓存最近访问的NPZ数据
- 预加载下一个batch的特征

#### 3.2 特征预取
- 在GPU计算时，CPU线程预取下一个batch的数据

### 4. 系统级优化

#### 4.1 文件系统优化
- 使用SSD而非HDD（如果可能）
- 调整文件系统挂载选项（如`noatime`）
- 使用tmpfs缓存临时数据

#### 4.2 进程级优化
- 减少并发训练任务数量
- 使用进程池而非线程池

## 实施优先级

### 高优先级（立即实施）
1. ✅ 增加DataLoader的`prefetch_factor`
2. ✅ 实现图像LRU缓存
3. ✅ 异步保存checkpoint

### 中优先级（短期实施）
4. 预加载NPZ索引
5. 批量特征读取
6. 优化图像加载库

### 低优先级（长期优化）
7. 系统级文件系统优化
8. 使用更快的存储介质

## 预期效果

- **I/O等待时间**：从41-70%降低到10-20%
- **训练速度**：提升20-40%
- **系统负载**：从136降低到80-100

