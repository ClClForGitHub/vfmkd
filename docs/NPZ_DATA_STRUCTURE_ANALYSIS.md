# NPZ 数据结构分析报告

## 📊 分析概述

本报告分析了 tar 文件中 npz 文件的数据结构，用于设计高效的二进制存储格式。

**分析样本**: 50 个 npz 文件（来自 `sa1b_shard_00000.tar`）  
**分析时间**: 2024年

## 📈 统计摘要

- **总键数**: 24
- **定长键数**: 20 (83.3%)
- **变长键数**: 4 (16.7%)
- **可优化为定长**: 1 (`image_shape`)
- **建议忽略**: 1 (`edge_original`)
- **实际需要索引**: 2 (`bboxes`, `masks`)

**优化后**:
- **定长键数**: 21 (87.5%) - 包括 `image_shape`
- **变长键数**: 2 (8.3%) - 仅 `bboxes` 和 `masks`

## ✅ 定长数据（Fixed Length）

以下数据在所有样本中形状完全一致，可以直接拼接存储：

### 特征数据（Features）
| 键名 | 形状 | 类型 | 大小 (bytes) | 说明 |
|------|------|------|--------------|------|
| `P4_S16` | `(1, 256, 64, 64)` | `float32` | 4,194,304 | SAM2 P4 特征（s16） |
| `P5_S32` | `(1, 256, 32, 32)` | `float32` | 1,048,576 | SAM2 P5 特征（s32） |
| `IMAGE_EMB_S16` | `(1, 256, 64, 64)` | `float32` | 4,194,304 | 兼容键（与 P4_S16 相同） |

### 边缘图（Edge Maps）
| 键名 | 形状 | 类型 | 大小 (bytes) | 说明 |
|------|------|------|--------------|------|
| `edge_256x256` | `(256, 256)` | `uint8` | 65,536 | 256×256 边缘图 |
| `edge_64x64` | `(64, 64)` | `uint8` | 4,096 | 64×64 边缘图（对应 P4） |
| `edge_32x32` | `(32, 32)` | `uint8` | 1,024 | 32×32 边缘图（对应 P5） |

### 权重图（Weight Maps）
| 键名 | 形状 | 类型 | 大小 (bytes) | 说明 |
|------|------|------|--------------|------|
| `fg_map_128x128` | `(128, 128)` | `float32` | 65,536 | 前景权重图 128×128 |
| `bg_map_128x128` | `(128, 128)` | `float32` | 65,536 | 背景权重图 128×128 |
| `fg_map_64x64` | `(64, 64)` | `float32` | 16,384 | 前景权重图 64×64 |
| `bg_map_64x64` | `(64, 64)` | `float32` | 16,384 | 背景权重图 64×64 |
| `fg_map_32x32` | `(32, 32)` | `float32` | 4,096 | 前景权重图 32×32 |
| `bg_map_32x32` | `(32, 32)` | `float32` | 4,096 | 背景权重图 32×32 |

### 元数据（Metadata）
| 键名 | 形状 | 类型 | 说明 |
|------|------|------|------|
| `image_id` | `()` | `str` | 图像 ID（字符串） |
| `model_type` | `()` | `str` | 模型类型 |
| `feature_flag` | `()` | `int64` | 特征提取标志 |
| `edge_flag` | `()` | `uint8` | 边缘提取标志 |
| `edge_version` | `()` | `str` | 边缘提取版本 |
| `has_bbox` | `()` | `bool` | 是否有边界框 |
| `num_bboxes` | `()` | `int32` | 边界框数量 |
| `geometry_color_flag` | `()` | `uint8` | 几何颜色策略标志 |

**定长数据总大小**: 约 9.6 MB/样本（仅特征和边缘图，不含元数据）

## ⚠️ 变长数据（Variable Length）

以下数据在不同样本中形状不同，需要索引文件：

### 1. `image_shape` - 图像尺寸 ✅ **可处理为定长**
- **形状**: `(3,)` - **形状固定**，但值不同（不同图像尺寸）
- **类型**: `int64`（可转换为 `int32` 节省空间）
- **说明**: 存储原始图像的 [H, W, C] 尺寸
- **实际分析**: 100 个样本中，形状全部为 `(3,)`，类型统一为 `int64`
- **存储方案**: ✅ **可以按定长处理**
  - 每个样本固定 12 bytes（3个 `int32`）或 24 bytes（3个 `int64`）
  - 存储方式：`image_shapes.bin`（直接拼接）
  - 读取方式：`offset = sample_id * 12`，读取 12 bytes，解析为 `(3,) int32`

### 2. `bboxes` - 边界框
- **形状变化**: `(0, 4)` 或 `(1, 4)` - 不同样本的框数量不同
- **类型**: `float32`
- **说明**: 存储边界框坐标 [x, y, w, h]
- **存储方案**: 需要索引文件记录每个样本的框数量

### 3. `masks` - 掩码
- **形状变化**: 15 种不同的形状
- **示例形状**: 
  - `(1, 1500, 2254)`
  - `(1, 2250, 1500)`
  - `(1, 1500, 2000)`
  - `(1, 1500, 2247)`
  - `(1, 1500, 2719)`
- **类型**: `object` (存储 numpy 数组)
- **说明**: 每个掩码的尺寸都不同，取决于原始图像尺寸
- **存储方案**: 必须使用索引文件，记录每个掩码的 offset 和 size

### 4. `edge_original` - 原始尺寸边缘图 ⚠️ **建议忽略**
- **形状变化**: `(1500, 2250)`, `(2250, 1500)`, `(1500, 2000)` - 3 种不同形状
- **类型**: `uint8`
- **说明**: 原始图像尺寸的边缘图
- **实际分析**: 100 个样本中，只有 9% 的样本包含此字段（9/100）
- **存储方案**: 
  - ✅ **推荐方案1**: 完全忽略此字段（大多数样本都没有，且已有固定尺寸的边缘图）
  - 方案2: 如果需要，统一 resize 到固定尺寸（如 1024×1024），然后按定长存储
  - 方案3: 保持变长，使用索引文件（不推荐，因为使用率低）

## 💡 存储格式设计建议

### 方案 A：混合存储（推荐）

**定长数据** - 直接拼接存储（类似 EdgeSAM）：
```
features.bin          # P4_S16, P5_S32, IMAGE_EMB_S16
edge_maps.bin         # edge_256x256, edge_64x64, edge_32x32
weight_maps.bin       # fg_map_*, bg_map_* (所有尺寸)
metadata.bin          # 元数据（image_id, flags 等）
image_shapes.bin      # 图像尺寸（固定 3×int32，12 bytes/样本）✅ 优化为定长
```

**变长数据** - 索引 + 数据：
```
bboxes.bin            # 所有边界框数据（拼接）
bboxes.idx            # 索引：sample_id, offset, count, dtype
masks.bin             # 所有掩码数据（拼接）
masks.idx             # 索引：sample_id, offset, shape, dtype
```

**忽略的数据**（不存储）：
```
edge_original         # 原始尺寸边缘图（使用率仅 9%，建议忽略）✅ 优化：不存储
```

**定长数据（包括优化后的）**：
```
image_shapes.bin      # 所有图像尺寸（固定 3×int32，12 bytes/样本）
```

**优势**:
- 定长数据读取最快（直接计算偏移量）
- 变长数据有索引支持，查找方便
- 列式存储，可以按需加载

### 方案 B：完全列式存储

将所有键拆分到独立的 .bin 文件：
```
P4_S16.bin
P5_S32.bin
edge_256x256.bin
edge_64x64.bin
edge_32x32.bin
fg_map_128x128.bin
bg_map_128x128.bin
...
bboxes.bin + bboxes.idx
masks.bin + masks.idx
```

**优势**:
- 最灵活，可以按需加载特定键
- 易于扩展新键

**劣势**:
- 文件数量多
- 需要管理多个文件

### 索引文件格式

对于变长数据，索引文件建议格式：

**二进制索引格式**（推荐）:
```python
# 每个索引条目（固定大小）
struct IndexEntry:
    sample_id: uint64      # 样本 ID（或索引）
    offset: uint64         # 在 .bin 文件中的字节偏移
    length: uint32         # 数据长度（字节数）
    shape_0: uint32        # 形状维度 0（对于 masks）
    shape_1: uint32        # 形状维度 1（对于 masks）
    shape_2: uint32        # 形状维度 2（对于 masks）
    dtype: uint8           # 数据类型代码
```

**文本索引格式**（便于调试）:
```
sample_id,offset,length,shape,dtype
0,0,16,"(1, 4)",float32
1,16,0,"(0, 4)",float32
2,16,16,"(1, 4)",float32
```

### 样本 ID 映射文件

建议创建 `keys.txt` 或 `sample_ids.txt`：
```
sa_000000
sa_000001
sa_000002
...
```

用于将样本索引映射到原始图像 ID。

## 📐 存储大小估算

假设有 1000 个样本：

**定长数据总大小**:
- 特征: 3 × 4,194,304 + 1,048,576 = 13,631,488 bytes ≈ 13 MB
- 边缘图: 65,536 + 4,096 + 1,024 = 70,656 bytes ≈ 69 KB
- 权重图: 6 × (65,536 + 16,384 + 4,096) = 515,328 bytes ≈ 503 KB
- **总计**: 约 13.6 MB/样本 × 1000 = 13.6 GB

**变长数据**:
- `bboxes`: 平均每个样本 1 个框 × 4 × 4 bytes = 16 bytes，总计约 16 KB
- `masks`: 平均每个掩码约 3-6 MB，总计约 3-6 GB
- `image_shapes`: 1000 × 3 × 4 bytes = 12 KB

**总存储大小**: 约 17-20 GB（1000 样本）

## 🚀 实现建议

1. **优先实现定长数据存储**（方案 A 的定长部分）
   - 实现简单，性能最优
   - 覆盖 83% 的数据

2. **变长数据可以暂时保留在 npz 中**
   - 或者使用简单的索引文件
   - 按需实现完整的索引系统

3. **支持渐进式迁移**
   - 先转换定长数据到 .bin
   - 变长数据仍从 npz 读取
   - 逐步迁移变长数据

## 📝 结论

- **87.5% 的数据是定长的**（优化后），可以直接拼接存储，性能最优
  - 包括：所有特征、边缘图、权重图、元数据，以及 `image_shape`
- **8.3% 的数据是变长的**，需要索引文件支持
  - 仅：`bboxes` 和 `masks`
- **4.2% 的数据建议忽略**（`edge_original`，使用率仅 9%）
- **推荐方案 A（混合存储）**，兼顾性能和灵活性
- **定长数据优先实现**，变长数据可以后续优化

### 优化建议总结

1. ✅ **`image_shape`**: 按定长处理，12 bytes/样本（3个 int32）
2. ✅ **`edge_original`**: 建议完全忽略（使用率低，且已有固定尺寸边缘图）
3. ⚠️ **`bboxes`**: 保持变长，使用索引文件
4. ⚠️ **`masks`**: 保持变长，使用索引文件

**优化效果**: 定长数据从 83.3% 提升到 87.5%，变长数据从 16.7% 降低到 8.3%

